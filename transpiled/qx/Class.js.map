{
  "version": 3,
  "sources": [
    "/home/travis/build/qooxdoo/qxl.dialog/node_modules/@qooxdoo/compiler/node_modules/@qooxdoo/framework/source/class/qx/Class.js"
  ],
  "names": [
    "qx",
    "Bootstrap",
    "executePendingDefers",
    "$$dbClassInfo",
    "define",
    "statics",
    "__Property",
    "core",
    "Property",
    "name",
    "config",
    "include",
    "getClass",
    "implement",
    "implicitType",
    "hasOwnProperty",
    "type",
    "__validateConfig",
    "ex",
    "message",
    "clazz",
    "__createClass",
    "extend",
    "construct",
    "destruct",
    "forEach",
    "id",
    "__attachAnno",
    "properties",
    "__addProperties",
    "members",
    "__addMembers",
    "events",
    "__addEvents",
    "i",
    "l",
    "length",
    "__addMixin",
    "Error",
    "environment",
    "key",
    "Environment",
    "add",
    "__addInterface",
    "__validateAbstractInterfaces",
    "defer",
    "self",
    "addPendingDefer",
    "prototype",
    "Class",
    "undefine",
    "$$registry",
    "ns",
    "split",
    "objects",
    "window",
    "push",
    "last",
    "parent",
    "isFunction",
    "objectGetLength",
    "isDefined",
    "util",
    "OOUtil",
    "classIsDefined",
    "getTotalNumber",
    "getByName",
    "mixin",
    "classname",
    "Mixin",
    "isCompatible",
    "patch",
    "isClass",
    "obj",
    "$$type",
    "constructor",
    "isSubClassOf",
    "superClass",
    "getPropertyDefinition",
    "getProperties",
    "list",
    "$$properties",
    "apply",
    "Object",
    "keys",
    "superclass",
    "getByProperty",
    "hasProperty",
    "getEventType",
    "supportsEvent",
    "hasOwnMixin",
    "$$includes",
    "indexOf",
    "getByMixin",
    "$$flatIncludes",
    "getMixins",
    "hasMixin",
    "hasOwnInterface",
    "iface",
    "$$implements",
    "getByInterface",
    "getInterfaces",
    "$$flatImplements",
    "hasInterface",
    "implementsInterface",
    "Interface",
    "objectImplements",
    "classImplements",
    "getInstance",
    "$$instance",
    "$$allowconstruct",
    "getSubclasses",
    "subclasses",
    "registry",
    "genericToString",
    "__allowedKeys",
    "__staticAllowedKeys",
    "allowed",
    "maps",
    "undefined",
    "$$hash",
    "isObject",
    "a",
    "checkCompatibility",
    "substr",
    "settings",
    "variants",
    "$$classtype",
    "interfaces",
    "assert",
    "group",
    "anno",
    "$$annotations",
    "lang",
    "Type",
    "isArray",
    "mixins",
    "isStrictMode",
    "setDisplayNames",
    "__createDefaultConstructor",
    "__needsConstructorWrapper",
    "__wrapConstructor",
    "setDisplayName",
    "staticValue",
    "charAt",
    "substring",
    "basename",
    "createNamespace",
    "toString",
    "extendClass",
    "$$destructor",
    "$$events",
    "proto",
    "__validateProperty",
    "refine",
    "init",
    "event",
    "async",
    "inheritable",
    "$$inheritable",
    "$$refreshInheritables",
    "attachRefreshInheritables",
    "attachMethods",
    "has",
    "existingProperty",
    "$$allowedGroupKeys",
    "$$allowedKeys",
    "transform",
    "check",
    "isString",
    "base",
    "wrap",
    "member",
    "annoKey",
    "$$install",
    "Function",
    "__mixinMemberWrapper",
    "oldBase",
    "retval",
    "arguments",
    "flatten",
    "__retrospectWrapConstruct",
    "wrapper",
    "method",
    "$$original",
    "isConstructorWrapped",
    "$$constructor",
    "entry",
    "$$members",
    "defaultConstructor",
    "baseMixins",
    "flatMixins",
    "$$initialized"
  ],
  "mappings": "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",
  "sourcesContent": [
    "/* ************************************************************************\n\n   qooxdoo - the new era of web development\n\n   http://qooxdoo.org\n\n   Copyright:\n     2004-2008 1&1 Internet AG, Germany, http://www.1und1.de\n\n   License:\n     MIT: https://opensource.org/licenses/MIT\n     See the LICENSE file in the project's top-level directory for details.\n\n   Authors:\n     * Sebastian Werner (wpbasti)\n     * Andreas Ecker (ecker)\n     * John Spackman (john.spackman@zenesis.com)\n\n************************************************************************ */\n\n/**\n * This class is one of the most important parts of qooxdoo's\n * object-oriented features.\n *\n * Its {@link #define} method is used to create qooxdoo classes.\n *\n * Each instance of a class defined by {@link #define} has\n * the following keys attached to the constructor and the prototype:\n *\n * <table>\n * <tr><th><code>classname</code></th><td>The fully-qualified name of the class (e.g. <code>\"qx.ui.core.Widget\"</code>).</td></tr>\n * <tr><th><code>basename</code></th><td>The namespace part of the class name (e.g. <code>\"qx.ui.core\"</code>).</td></tr>\n * <tr><th><code>constructor</code></th><td>A reference to the constructor of the class.</td></tr>\n * <tr><th><code>superclass</code></th><td>A reference to the constructor of the super class.</td></tr>\n * </table>\n *\n * Each method may access static members of the same class by using\n * <code>this.self(arguments)</code> ({@link qx.core.Object#self}):\n * <pre class='javascript'>\n * statics : { FOO : \"bar\" },\n * members: {\n *   baz: function(x) {\n *     this.self(arguments).FOO;\n *     ...\n *   }\n * }\n * </pre>\n *\n * Each overriding method may call the overridden method by using\n * <code>this.base(arguments [, ...])</code> ({@link qx.core.Object#base}). This is also true for calling\n * the constructor of the superclass.\n * <pre class='javascript'>\n * members: {\n *   foo: function(x) {\n *     this.base(arguments, x);\n *     ...\n *   }\n * }\n * </pre>\n *\n * By using <code>qx.Class</code> within an app, the native JS data types are\n * conveniently polyfilled according to {@link qx.lang.normalize}.\n * \n * Annotations can be added to classes, constructors, destructors, and methods, properties, and statics - \n * see <code>qx.Annotation</code> for examples and means access annotations at runtime.\n *\n * @require(qx.Interface)\n * @require(qx.Mixin)\n * @require(qx.lang.normalize.Array)\n * @require(qx.lang.normalize.Date)\n * @require(qx.lang.normalize.Error)\n * @require(qx.lang.normalize.Function)\n * @require(qx.lang.normalize.String)\n * @require(qx.lang.normalize.Object)\n * @require(qx.lang.normalize.Number)\n */\nqx.Bootstrap.define(\"qx.Class\",\n{\n  statics :\n  {\n    /**\n     * A static reference to the property implementation in the case it\n     * should be included.\n     */\n    __Property : qx.core.Environment.get(\"module.property\") ? qx.core.Property : null,\n\n    /*\n    ---------------------------------------------------------------------------\n       PUBLIC METHODS\n    ---------------------------------------------------------------------------\n    */\n\n    /**\n     * Define a new class using the qooxdoo class system. This sets up the\n     * namespace for the class and generates the class from the definition map.\n     *\n     * Example:\n     * <pre class='javascript'>\n     * qx.Class.define(\"name\",\n     * {\n     *   extend : Object, // superclass\n     *   implement : [Interfaces],\n     *   include : [Mixins],\n     *\n     *   statics:\n     *   {\n     *     CONSTANT : 3.141,\n     *\n     *     publicMethod: function() {},\n     *     _protectedMethod: function() {},\n     *     __privateMethod: function() {}\n     *   },\n     *\n     *   properties:\n     *   {\n     *     \"tabIndex\": { check: \"Number\", init : -1 }\n     *   },\n     *\n     *   members:\n     *   {\n     *     publicField: \"foo\",\n     *     publicMethod: function() {},\n     *\n     *     _protectedField: \"bar\",\n     *     _protectedMethod: function() {},\n     *\n     *     __privateField: \"baz\",\n     *     __privateMethod: function() {}\n     *   }\n     * });\n     * </pre>\n     *\n     * @param name {String?null} Name of the class. If <code>null</code>, the class\n     *   will not be added to any namespace which could be handy for testing.\n     * @param config {Map ? null} Class definition structure. The configuration map has the following keys:\n     *     <table>\n     *       <tr><th>Name</th><th>Type</th><th>Description</th></tr>\n     *       <tr><th>type</th><td>String</td><td>\n     *           Type of the class. Valid types are \"abstract\", \"static\" and \"singleton\".\n     *           If unset it defaults to a regular non-static class.\n     *       </td></tr>\n     *       <tr><th>extend</th><td>Class</td><td>The super class the current class inherits from.</td></tr>\n     *       <tr><th>implement</th><td>Interface | Interface[]</td><td>Single interface or array of interfaces the class implements.</td></tr>\n     *       <tr><th>include</th><td>Mixin | Mixin[]</td><td>Single mixin or array of mixins, which will be merged into the class.</td></tr>\n     *       <tr><th>construct</th><td>Function</td><td>The constructor of the class.</td></tr>\n     *       <tr><th>statics</th><td>Map</td><td>Map of static members of the class.</td></tr>\n     *       <tr><th>properties</th><td>Map</td><td>Map of property definitions. For a description of the format of a property definition see\n     *           {@link qx.core.Property}.</td></tr>\n     *       <tr><th>members</th><td>Map</td><td>Map of instance members of the class.</td></tr>\n     *       <tr><th>environment</th><td>Map</td><td>Map of environment settings for this class. For a description of the format of a setting see\n     *           {@link qx.core.Environment}.</td></tr>\n     *       <tr><th>events</th><td>Map</td><td>\n     *           Map of events the class fires. The keys are the names of the events and the values are the\n     *           corresponding event type class names.\n     *       </td></tr>\n     *       <tr><th>defer</th><td>Function</td><td>Function that is called at the end of processing the class declaration. It allows access to the declared statics, members and properties.</td></tr>\n     *       <tr><th>destruct</th><td>Function</td><td>The destructor of the class.</td></tr>\n     *     </table>\n     * @return {Class} The defined class\n     */\n    define : function(name, config)\n    {\n      if (!config) {\n        config = {};\n      }\n\n      // Normalize include to array\n      if (config.include && !(qx.Bootstrap.getClass(config.include) === \"Array\")) {\n        config.include = [config.include];\n      }\n\n      // Normalize implement to array\n      if (config.implement && !(qx.Bootstrap.getClass(config.implement) === \"Array\")) {\n        config.implement = [config.implement];\n      }\n\n      // Normalize type\n      var implicitType = false;\n      if (!config.hasOwnProperty(\"extend\") && !config.type) {\n        config.type = \"static\";\n        implicitType = true;\n      }\n\n      // Validate incoming data\n      if (qx.core.Environment.get(\"qx.debug\")) {\n        try {\n          this.__validateConfig(name, config);\n        } catch(ex) {\n          if (implicitType) {\n            ex.message = 'Assumed static class because no \"extend\" key was found. ' + ex.message;\n          }\n          throw ex;\n        }\n      }\n\n      // Create the class\n      var clazz = this.__createClass(name, config.type, config.extend, config.statics, config.construct, config.destruct, config.include);\n      \n      // Initialise class and constructor/destructor annotations\n      [ \"@\", \"@construct\", \"@destruct\" ].forEach(function(id) {\n        this.__attachAnno(clazz, id, null, config[id]);\n      }, this);\n\n      // Members, properties, events and mixins are only allowed for non-static classes\n      if (config.extend)\n      {\n        // Attach properties\n        if (config.properties) {\n          this.__addProperties(clazz, config.properties, true);\n        }\n\n        // Attach members\n        if (config.members) {\n          this.__addMembers(clazz, config.members, true, true, false);\n        }\n\n        // Process events\n        if (config.events) {\n          this.__addEvents(clazz, config.events, true);\n        }\n\n        // Include mixins\n        // Must be the last here to detect conflicts\n        if (config.include)\n        {\n          for (var i=0, l=config.include.length; i<l; i++) {\n            this.__addMixin(clazz, config.include[i], false);\n          }\n        }\n      }\n      // If config has a 'extend' key but it's null or undefined\n      else if (config.hasOwnProperty('extend') && qx.core.Environment.get(\"qx.debug\"))\n      {\n         throw new Error('\"extend\" parameter is null or undefined');\n      }\n\n      // Process environment\n      if (config.environment)\n      {\n        for (var key in config.environment) {\n          qx.core.Environment.add(key, config.environment[key]);\n        }\n      }\n\n      // Interface support for non-static classes\n      if (config.implement)\n      {\n        for (var i=0, l=config.implement.length; i<l; i++) {\n          this.__addInterface(clazz, config.implement[i]);\n        }\n      }\n\n\n      if (qx.core.Environment.get(\"qx.debug\")) {\n        this.__validateAbstractInterfaces(clazz);\n      }\n\n\n      // Process defer\n      if (config.defer)\n      {\n        config.defer.self = clazz;\n        qx.Bootstrap.addPendingDefer(clazz, function() {\n          config.defer(clazz, clazz.prototype,\n            {\n              add : function(name, config)\n              {\n                // build pseudo properties map\n                var properties = {};\n                properties[name] = config;\n\n                // execute generic property handler\n                qx.Class.__addProperties(clazz, properties, true);\n              }\n            });\n        });\n      }\n\n      return clazz;\n    },\n\n\n    /**\n     * Removes a class from qooxdoo defined by {@link #define}\n     *\n     * @param name {String} Name of the class\n     */\n    undefine : function(name)\n    {\n      // first, delete the class from the registry\n      delete this.$$registry[name];\n      // delete the class reference from the namespaces and all empty namespaces\n      var ns = name.split(\".\");\n      // build up an array containing all namespace objects including window\n      var objects = [window];\n      for (var i = 0; i < ns.length; i++) {\n        objects.push(objects[i][ns[i]]);\n      }\n\n      // go through all objects and check for the constructor or empty namespaces\n      for (var i = objects.length - 1; i >= 1; i--) {\n        var last = objects[i];\n        var parent = objects[i - 1];\n        if (qx.Bootstrap.isFunction(last) || qx.Bootstrap.objectGetLength(last) === 0) {\n          delete parent[ns[i - 1]];\n        } else {\n          break;\n        }\n      }\n    },\n\n\n    /**\n     * Whether the given class exists\n     *\n     * @signature function(name)\n     * @param name {String} class name to check\n     * @return {Boolean} true if class exists\n     */\n    isDefined : qx.util.OOUtil.classIsDefined,\n\n\n    /**\n     * Determine the total number of classes\n     *\n     * @return {Number} the total number of classes\n     */\n    getTotalNumber : function() {\n      return qx.Bootstrap.objectGetLength(this.$$registry);\n    },\n\n\n    /**\n     * Find a class by its name\n     *\n     * @signature function(name)\n     * @param name {String} class name to resolve\n     * @return {Class} the class\n     */\n    getByName : qx.Bootstrap.getByName,\n\n\n    /**\n     * Include all features of the given mixin into the class. The mixin must\n     * not include any methods or properties that are already available in the\n     * class. This would only be possible using the {@link #patch} method.\n     *\n     * @param clazz {Class} An existing class which should be augmented by including a mixin.\n     * @param mixin {Mixin} The mixin to be included.\n     */\n    include : function(clazz, mixin)\n    {\n      if (qx.core.Environment.get(\"qx.debug\"))\n      {\n        if (!mixin) {\n          throw new Error(\"The mixin to include into class '\" + clazz.classname + \"' is undefined/null!\");\n        }\n\n        qx.Mixin.isCompatible(mixin, clazz);\n      }\n\n      qx.Class.__addMixin(clazz, mixin, false);\n    },\n\n\n    /**\n     * Include all features of the given mixin into the class. The mixin may\n     * include features, which are already defined in the target class. Existing\n     * features of equal name will be overwritten.\n     * Please keep in mind that this functionality is not intended for regular\n     * use, but as a formalized way (and a last resort) in order to patch\n     * existing classes.\n     *\n     * <b>WARNING</b>: You may break working classes and features.\n     *\n     * @param clazz {Class} An existing class which should be modified by including a mixin.\n     * @param mixin {Mixin} The mixin to be included.\n     */\n    patch : function(clazz, mixin)\n    {\n      if (qx.core.Environment.get(\"qx.debug\"))\n      {\n        if (!mixin) {\n          throw new Error(\"The mixin to patch class '\" + clazz.classname + \"' is undefined/null!\");\n        }\n\n        qx.Mixin.isCompatible(mixin, clazz);\n      }\n\n      qx.Class.__addMixin(clazz, mixin, true);\n    },\n    \n    \n    /**\n     * Detects whether the object is a Class (and not an instance of a class)\n     * \n     *  @param obj {Object?} the object to inspect\n     *  @return {Boolean} true if it is a class, false if it is anything else\n     */\n    isClass: function(obj) {\n      return obj && obj.$$type === \"Class\" && obj.constructor === obj;\n    },\n\n\n    /**\n     * Whether a class is a direct or indirect sub class of another class,\n     * or both classes coincide.\n     *\n     * @param clazz {Class} the class to check.\n     * @param superClass {Class} the potential super class\n     * @return {Boolean} whether clazz is a sub class of superClass.\n     */\n    isSubClassOf : function(clazz, superClass)\n    {\n      if (!clazz) {\n        return false;\n      }\n\n      if (clazz == superClass) {\n        return true;\n      }\n\n      if (clazz.prototype instanceof superClass) {\n        return true;\n      }\n\n      return false;\n    },\n\n\n    /**\n     * Returns the definition of the given property. Returns null\n     * if the property does not exist.\n     *\n     * @signature function(clazz, name)\n     * @param clazz {Class} class to check\n     * @param name {String} name of the class to check for\n     * @return {Map|null} whether the object support the given event.\n     */\n    getPropertyDefinition : qx.util.OOUtil.getPropertyDefinition,\n\n\n    /**\n     * Returns a list of all properties supported by the given class\n     *\n     * @param clazz {Class} Class to query\n     * @return {String[]} List of all property names\n     */\n    getProperties : function(clazz)\n    {\n      var list = [];\n\n      while (clazz)\n      {\n        if (clazz.$$properties) {\n          list.push.apply(list, Object.keys(clazz.$$properties));\n        }\n\n        clazz = clazz.superclass;\n      }\n\n      return list;\n    },\n\n\n    /**\n     * Returns the class or one of its superclasses which contains the\n     * declaration for the given property in its class definition. Returns null\n     * if the property is not specified anywhere.\n     *\n     * @param clazz {Class} class to look for the property\n     * @param name {String} name of the property\n     * @return {Class | null} The class which includes the property\n     */\n    getByProperty : function(clazz, name)\n    {\n      while (clazz)\n      {\n        if (clazz.$$properties && clazz.$$properties[name]) {\n          return clazz;\n        }\n\n        clazz = clazz.superclass;\n      }\n\n      return null;\n    },\n\n\n    /**\n     * Whether a class has the given property\n     *\n     * @signature function(clazz, name)\n     * @param clazz {Class} class to check\n     * @param name {String} name of the property to check for\n     * @return {Boolean} whether the class includes the given property.\n     */\n    hasProperty : qx.util.OOUtil.hasProperty,\n\n\n    /**\n     * Returns the event type of the given event. Returns null if\n     * the event does not exist.\n     *\n     * @signature function(clazz, name)\n     * @param clazz {Class} class to check\n     * @param name {String} name of the event\n     * @return {String|null} Event type of the given event.\n     */\n    getEventType : qx.util.OOUtil.getEventType,\n\n\n    /**\n     * Whether a class supports the given event type\n     *\n     * @signature function(clazz, name)\n     * @param clazz {Class} class to check\n     * @param name {String} name of the event to check for\n     * @return {Boolean} whether the class supports the given event.\n     */\n    supportsEvent : qx.util.OOUtil.supportsEvent,\n\n\n    /**\n     * Whether a class directly includes a mixin.\n     *\n     * @param clazz {Class} class to check\n     * @param mixin {Mixin} the mixin to check for\n     * @return {Boolean} whether the class includes the mixin directly.\n     */\n    hasOwnMixin : function(clazz, mixin) {\n      return clazz.$$includes && clazz.$$includes.indexOf(mixin) !== -1;\n    },\n\n\n    /**\n     * Returns the class or one of its superclasses which contains the\n     * declaration for the given mixin. Returns null if the mixin is not\n     * specified anywhere.\n     *\n     * @param clazz {Class} class to look for the mixin\n     * @param mixin {Mixin} mixin to look for\n     * @return {Class | null} The class which directly includes the given mixin\n     */\n    getByMixin : function(clazz, mixin)\n    {\n      var list, i, l;\n\n      while (clazz)\n      {\n        if (clazz.$$includes)\n        {\n          list = clazz.$$flatIncludes;\n\n          for (i=0, l=list.length; i<l; i++)\n          {\n            if (list[i] === mixin) {\n              return clazz;\n            }\n          }\n        }\n\n        clazz = clazz.superclass;\n      }\n\n      return null;\n    },\n\n\n    /**\n     * Returns a list of all mixins available in a given class.\n     *\n     * @signature function(clazz)\n     * @param clazz {Class} class which should be inspected\n     * @return {Mixin[]} array of mixins this class uses\n     */\n    getMixins : qx.util.OOUtil.getMixins,\n\n\n    /**\n     * Whether a given class or any of its superclasses includes a given mixin.\n     *\n     * @param clazz {Class} class to check\n     * @param mixin {Mixin} the mixin to check for\n     * @return {Boolean} whether the class includes the mixin.\n     */\n    hasMixin: function(clazz, mixin) {\n      return !!this.getByMixin(clazz, mixin);\n    },\n\n\n    /**\n     * Whether a given class directly includes an interface.\n     *\n     * This function will only return \"true\" if the interface was defined\n     * in the class declaration ({@link qx.Class#define}) using the \"implement\"\n     * key.\n     *\n     * @param clazz {Class} class or instance to check\n     * @param iface {Interface} the interface to check for\n     * @return {Boolean} whether the class includes the mixin directly.\n     */\n    hasOwnInterface : function(clazz, iface) {\n      return clazz.$$implements && clazz.$$implements.indexOf(iface) !== -1;\n    },\n\n\n    /**\n     * Returns the class or one of its super classes which contains the\n     * declaration of the given interface. Returns null if the interface is not\n     * specified anywhere.\n     *\n     * @signature function(clazz, iface)\n     * @param clazz {Class} class to look for the interface\n     * @param iface {Interface} interface to look for\n     * @return {Class | null} the class which directly implements the given interface\n     */\n    getByInterface : qx.util.OOUtil.getByInterface,\n\n\n    /**\n     * Returns a list of all interfaces a given class has to implement.\n     *\n     * @param clazz {Class} class which should be inspected\n     * @return {Interface[]} array of interfaces this class implements\n     */\n    getInterfaces : function(clazz)\n    {\n      var list = [];\n\n      while (clazz)\n      {\n        if (clazz.$$implements) {\n          list.push.apply(list, clazz.$$flatImplements);\n        }\n\n        clazz = clazz.superclass;\n      }\n\n      return list;\n    },\n\n\n    /**\n     * Whether a given class or any of its super classes includes a given interface.\n     *\n     * This function will return \"true\" if the interface was defined\n     * in the class declaration ({@link qx.Class#define}) of the class\n     * or any of its super classes using the \"implement\"\n     * key.\n     *\n     * @signature function(clazz, iface)\n     * @param clazz {Class} class to check\n     * @param iface {Interface} the interface to check for\n     * @return {Boolean} whether the class includes the interface.\n     */\n    hasInterface : qx.util.OOUtil.hasInterface,\n\n\n    /**\n     * Whether a given class complies to an interface.\n     *\n     * Checks whether all methods defined in the interface are\n     * implemented. The class does not need to implement\n     * the interface explicitly in the <code>extend</code> key.\n     *\n     * @param obj {Object} class to check\n     * @param iface {Interface} the interface to check for\n     * @return {Boolean} whether the class conforms to the interface.\n     */\n    implementsInterface : function(obj, iface)\n    {\n      var clazz = obj.constructor;\n\n      if (this.hasInterface(clazz, iface)) {\n        return true;\n      }\n\n      if (qx.Interface.objectImplements(obj, iface)) {\n        return true;\n      }\n\n      if (qx.Interface.classImplements(clazz, iface)) {\n        return true;\n      }\n\n      return false;\n    },\n\n\n    /**\n     * Helper method to handle singletons\n     *\n     * @internal\n     * @return {Object} The singleton instance\n     */\n    getInstance : function()\n    {\n      if (this.$$instance === null)\n      {\n        throw new Error(\"Singleton instance of \" + this + \n          \" is requested, but not ready yet. This is most likely due to a recursive call in the constructor path.\");\n      }\n\n      if (!this.$$instance)\n      {\n        this.$$allowconstruct = true;\n        this.$$instance = null;  // null means \"object is being created\"; needed for another call of getInstance() during instantiation\n        this.$$instance = new this();\n        delete this.$$allowconstruct;\n      }\n\n      return this.$$instance;\n    },\n\n\n    /**\n     * Retreive all subclasses of a given class\n     *\n     * @param clazz {Class} the class which should be inspected\n     * \n     * @return {Object} class name hash holding the references to the subclasses or null if the class does not exist.\n     */\n    getSubclasses : function(clazz)\n    {\n      if(!clazz) {\n        return null;\n      }\n      \n      var subclasses = {};\n      var registry = qx.Class.$$registry;\n\n      for (var name in registry) {\n        if(registry[name].superclass && registry[name].superclass == clazz) {\n          subclasses[name] = registry[name];\n        }\n      }\n\n      return subclasses;\n    },\n\n\n\n    /*\n    ---------------------------------------------------------------------------\n       PRIVATE/INTERNAL BASICS\n    ---------------------------------------------------------------------------\n    */\n\n    /**\n     * This method will be attached to all classes to return\n     * a nice identifier for them.\n     *\n     * @internal\n     * @return {String} The class identifier\n     */\n    genericToString : function() {\n      return \"[Class \" + this.classname + \"]\";\n    },\n\n\n    /** Stores all defined classes */\n    $$registry : qx.Bootstrap.$$registry,\n\n\n    /** @type {Map} allowed keys in non-static class definition */\n    __allowedKeys : qx.core.Environment.select(\"qx.debug\",\n    {\n      \"true\":\n      {\n        \"@\"          : \"object\",\n        \"@construct\" : \"object\",\n        \"@destruct\"  : \"object\",\n        \"type\"       : \"string\",    // String\n        \"extend\"     : \"function\",  // Function\n        \"implement\"  : \"object\",    // Interface[]\n        \"include\"    : \"object\",    // Mixin[]\n        \"construct\"  : \"function\",  // Function\n        \"statics\"    : \"object\",    // Map\n        \"properties\" : \"object\",    // Map\n        \"members\"    : \"object\",    // Map\n        \"environment\"   : \"object\", // Map\n        \"events\"     : \"object\",    // Map\n        \"defer\"      : \"function\",  // Function\n        \"destruct\"   : \"function\"   // Function\n      },\n\n      \"default\" : null\n    }),\n\n\n    /** @type {Map} allowed keys in static class definition */\n    __staticAllowedKeys : qx.core.Environment.select(\"qx.debug\",\n    {\n      \"true\":\n      {\n        \"@\"           : \"object\",\n        \"type\"        : \"string\",    // String\n        \"statics\"     : \"object\",    // Map\n        \"environment\" : \"object\",    // Map\n        \"defer\"       : \"function\"   // Function\n      },\n\n      \"default\" : null\n    }),\n\n\n    /**\n     * Validates an incoming configuration and checks for proper keys and values\n     *\n     * @signature function(name, config)\n     * @param name {String} The name of the class\n     * @param config {Map} Configuration map\n     */\n    __validateConfig : qx.core.Environment.select(\"qx.debug\",\n    {\n      \"true\": function(name, config)\n      {\n        // Validate type\n        if (config.type && !(config.type === \"static\" || config.type === \"abstract\" || config.type === \"singleton\")) {\n          throw new Error('Invalid type \"' + config.type + '\" definition for class \"' + name + '\"!');\n        }\n\n        // Validate non-static class on the \"extend\" key\n        if (config.type && config.type !== \"static\" && !config.extend) {\n          throw new Error('Invalid config in class \"' + name + '\"! Every non-static class has to extend at least the \"qx.core.Object\" class.');\n        }\n\n        // Validate keys\n        var allowed = config.type === \"static\" ? this.__staticAllowedKeys : this.__allowedKeys;\n        for (var key in config)\n        {\n          if (!allowed[key]) {\n            throw new Error('The configuration key \"' + key + '\" in class \"' + name + '\" is not allowed!');\n          }\n\n          if (config[key] == null) {\n            throw new Error('Invalid key \"' + key + '\" in class \"' + name + '\"! The value is undefined/null!');\n          }\n\n          if (typeof config[key] !== allowed[key]) {\n            throw new Error('Invalid type of key \"' + key + '\" in class \"' + name + '\"! The type of the key must be \"' + allowed[key] + '\"!');\n          }\n        }\n\n        // Validate maps\n        var maps = [ \"statics\", \"properties\", \"members\", \"environment\", \"settings\", \"variants\", \"events\" ];\n        for (var i=0, l=maps.length; i<l; i++)\n        {\n          var key = maps[i];\n\n          if (config[key] !== undefined && (\n            config[key].$$hash !== undefined || !qx.Bootstrap.isObject(config[key])\n          )) {\n            throw new Error('Invalid key \"' + key + '\" in class \"' + name + '\"! The value needs to be a map!');\n          }\n        }\n\n        // Validate include definition\n        if (config.include)\n        {\n          if (qx.Bootstrap.getClass(config.include) === \"Array\")\n          {\n            for (var i=0, a=config.include, l=a.length; i<l; i++)\n            {\n              if (a[i] == null || a[i].$$type !== \"Mixin\") {\n                throw new Error('The include definition in class \"' + name + '\" contains an invalid mixin at position ' + i + ': ' + a[i]);\n              }\n            }\n          }\n          else\n          {\n            throw new Error('Invalid include definition in class \"' + name + '\"! Only mixins and arrays of mixins are allowed!');\n          }\n        }\n\n        // Validate implement definition\n        if (config.implement)\n        {\n          if (qx.Bootstrap.getClass(config.implement) === \"Array\")\n          {\n            for (var i=0, a=config.implement, l=a.length; i<l; i++)\n            {\n              if (a[i] == null || a[i].$$type !== \"Interface\") {\n                throw new Error('The implement definition in class \"' + name + '\" contains an invalid interface at position ' + i + ': ' + a[i]);\n              }\n            }\n          }\n          else\n          {\n            throw new Error('Invalid implement definition in class \"' + name + '\"! Only interfaces and arrays of interfaces are allowed!');\n          }\n        }\n\n        // Check mixin compatibility\n        if (config.include)\n        {\n          try {\n            qx.Mixin.checkCompatibility(config.include);\n          } catch(ex) {\n            throw new Error('Error in include definition of class \"' + name + '\"! ' + ex.message);\n          }\n        }\n\n        // Validate environment\n        if (config.environment)\n        {\n          for (var key in config.environment)\n          {\n            if (key.substr(0, key.indexOf(\".\")) != name.substr(0, name.indexOf(\".\"))) {\n              throw new Error('Forbidden environment setting \"' + key +\n                '\" found in \"' + name + '\". It is forbidden to define a ' +\n                'environment setting for an external namespace!');\n            }\n          }\n        }\n\n        // Validate settings\n        if (config.settings)\n        {\n          for (var key in config.settings)\n          {\n            if (key.substr(0, key.indexOf(\".\")) != name.substr(0, name.indexOf(\".\"))) {\n              throw new Error('Forbidden setting \"' + key + '\" found in \"' + name + '\". It is forbidden to define a default setting for an external namespace!');\n            }\n          }\n        }\n\n        // Validate variants\n        if (config.variants)\n        {\n          for (var key in config.variants)\n          {\n            if (key.substr(0, key.indexOf(\".\")) != name.substr(0, name.indexOf(\".\"))) {\n              throw new Error('Forbidden variant \"' + key + '\" found in \"' + name + '\". It is forbidden to define a variant for an external namespace!');\n            }\n          }\n        }\n      },\n\n      \"default\" : function(name, config) {}\n    }),\n\n\n    /**\n     * Validates the interfaces required by abstract base classes\n     *\n     * @signature function(clazz)\n     * @param clazz {Class} The configured class.\n     */\n    __validateAbstractInterfaces : qx.core.Environment.select(\"qx.debug\",\n    {\n      \"true\": function(clazz)\n      {\n        var superclass = clazz.superclass;\n        while (superclass)\n        {\n          if (superclass.$$classtype !== \"abstract\") {\n            break;\n          }\n\n          var interfaces = superclass.$$implements;\n          if (interfaces)\n          {\n            for (var i=0; i<interfaces.length; i++) {\n              qx.Interface.assert(clazz, interfaces[i], true);\n            }\n          }\n          superclass = superclass.superclass;\n        }\n      },\n\n      \"default\" : function(clazz) {}\n    }),\n    \n    \n    /**\n     * Attaches an annotation to a class\n     *\n     * @param clazz {Map} Static methods or fields\n     * @param group {String} Group name\n     * @param key {String} Name of the annotated item\n     * @param anno {Object} Annotation object\n     */\n    __attachAnno : function(clazz, group, key, anno) {\n      if (anno !== undefined) {\n        if (clazz.$$annotations === undefined) {\n          clazz.$$annotations = {};\n          clazz.$$annotations[group] = {};\n          \n        } else if (clazz.$$annotations[group] === undefined) {\n          clazz.$$annotations[group] = {};\n        }\n        \n        if (!qx.lang.Type.isArray(anno)) {\n          anno = [anno];\n        }\n        \n        if (key) {\n          clazz.$$annotations[group][key] = anno;\n        } else {\n          clazz.$$annotations[group] = anno;\n        }\n      }\n    },\n\n\n    /**\n     * Creates a class by type. Supports modern inheritance etc.\n     *\n     * @param name {String} Full name of the class\n     * @param type {String} type of the class, i.e. \"static\", \"abstract\" or \"singleton\"\n     * @param extend {Class} Superclass to inherit from\n     * @param statics {Map} Static methods or fields\n     * @param construct {Function} Constructor of the class\n     * @param destruct {Function} Destructor of the class\n     * @param mixins {Mixin[]} array of mixins of the class\n     * @return {Class} The generated class\n     */\n    __createClass : function(name, type, extend, statics, construct, destruct, mixins)\n    {\n      var isStrictMode = function () {\n        return (typeof this == 'undefined');\n      };\n\n      var clazz;\n\n      if (!extend && qx.core.Environment.get(\"qx.aspects\") == false)\n      {\n        // Create empty/non-empty class\n        clazz = statics || {};\n        qx.Bootstrap.setDisplayNames(clazz, name);\n      }\n      else\n      {\n        clazz = {};\n\n        if (extend)\n        {\n          // Create default constructor\n          if (!construct) {\n            construct = this.__createDefaultConstructor();\n          }\n\n          if (this.__needsConstructorWrapper(extend, mixins)) {\n            clazz = this.__wrapConstructor(construct, name, type);\n          } else {\n            clazz = construct;\n          }\n\n          // Add singleton getInstance()\n          if (type === \"singleton\") {\n            clazz.getInstance = this.getInstance;\n          }\n\n          qx.Bootstrap.setDisplayName(construct, name, \"constructor\");\n        }\n        \n        // Copy statics\n        if (statics)\n        {\n          qx.Bootstrap.setDisplayNames(statics, name);\n\n          var key;\n\n          for (var i=0, a=Object.keys(statics), l=a.length; i<l; i++)\n          {\n            key = a[i];\n            var staticValue = statics[key];\n\n            if (qx.core.Environment.get(\"qx.debug\")) {\n              if (key.charAt(0) === '@') {\n                if (statics[key.substring(1)] === undefined) {\n                  throw new Error('Annonation for static \"' + key.substring(1) + '\" of Class \"' + clazz.classname + '\" does not exist!');\n                }\n                if (key.charAt(1) === \"_\" && key.charAt(2) === \"_\") {\n                  throw new Error('Cannot annotate private static \"' + key.substring(1) + '\" of Class \"' + clazz.classname);\n                }\n              }\n            }\n            if (key.charAt(0) === '@') {\n              continue;\n            }\n\n            if (qx.core.Environment.get(\"qx.aspects\"))\n            {\n\n              if (staticValue instanceof Function) {\n                staticValue = qx.core.Aspect.wrap(name + \".\" + key, staticValue, \"static\");\n              }\n\n              clazz[key] = staticValue;\n            }\n            else\n            {\n              clazz[key] = staticValue;\n            }\n            \n            // Attach annotations\n            this.__attachAnno(clazz, \"statics\", key, statics[\"@\" + key]);\n          }\n        }\n      }\n\n      // Create namespace\n      var basename = name ? qx.Bootstrap.createNamespace(name, clazz) : \"\";\n\n      // Store names in constructor/object\n      clazz.classname = name;\n      if (!isStrictMode()) {\n        try {\n          clazz.name = name;\n        } catch(ex) {\n          // Nothing\n        }\n      }\n      clazz.basename = basename;\n\n      // Store type info\n      clazz.$$type = \"Class\";\n      if (type) {\n        clazz.$$classtype = type;\n      }\n\n      // Attach toString\n      if (!clazz.hasOwnProperty(\"toString\")) {\n        clazz.toString = this.genericToString;\n      }\n\n      if (extend)\n      {\n        qx.Bootstrap.extendClass(clazz, construct, extend, name, basename);\n\n        // Store destruct onto class\n        if (destruct)\n        {\n          if (qx.core.Environment.get(\"qx.aspects\")) {\n            destruct = qx.core.Aspect.wrap(name, destruct, \"destructor\");\n          }\n\n          clazz.$$destructor = destruct;\n          qx.Bootstrap.setDisplayName(destruct, name, \"destruct\");\n        }\n      }\n\n      // Store class reference in global class registry\n      this.$$registry[name] = clazz;\n\n      // Return final class object\n      return clazz;\n    },\n\n\n\n\n\n\n    /*\n    ---------------------------------------------------------------------------\n       PRIVATE ADD HELPERS\n    ---------------------------------------------------------------------------\n    */\n\n    /**\n     * Attach events to the class\n     *\n     * @param clazz {Class} class to add the events to\n     * @param events {Map} map of event names the class fires.\n     * @param patch {Boolean ? false} Enable redefinition of event type?\n     */\n    __addEvents : function(clazz, events, patch)\n    {\n      if (qx.core.Environment.get(\"qx.debug\"))\n      {\n        if (typeof events !== \"object\" || qx.Bootstrap.getClass(events) === \"Array\") {\n          throw new Error(clazz.classname + \": the events must be defined as map!\");\n        }\n\n        for (var key in events)\n        {\n          if (typeof events[key] !== \"string\") {\n            throw new Error(clazz.classname + \"/\" + key + \": the event value needs to be a string with the class name of the event object which will be fired.\");\n          }\n        }\n\n        // Compare old and new event type/value if patching is disabled\n        if (clazz.$$events && patch !== true)\n        {\n          for (var key in events)\n          {\n            if (clazz.$$events[key] !== undefined && clazz.$$events[key] !== events[key]) {\n              throw new Error(clazz.classname + \"/\" + key + \": the event value/type cannot be changed from \" + clazz.$$events[key] + \" to \" + events[key]);\n            }\n          }\n        }\n      }\n\n      if (clazz.$$events)\n      {\n        for (var key in events) {\n          clazz.$$events[key] = events[key];\n        }\n      }\n      else\n      {\n        clazz.$$events = events;\n      }\n    },\n\n\n    /**\n     * Attach properties to classes\n     *\n     * @param clazz {Class} class to add the properties to\n     * @param properties {Map} map of properties\n     * @param patch {Boolean ? false} Overwrite property with the limitations of a property\n               which means you are able to refine but not to replace (esp. for new properties)\n     */\n    __addProperties : function(clazz, properties, patch)\n    {\n      // check for the property module\n      if (!qx.core.Environment.get(\"module.property\")) {\n        throw new Error(\"Property module disabled.\");\n      }\n\n      var config;\n\n      if (patch === undefined) {\n        patch = false;\n      }\n\n      var proto = clazz.prototype;\n\n      for (var name in properties)\n      {\n        config = properties[name];\n\n        // Check incoming configuration\n        if (qx.core.Environment.get(\"qx.debug\")) {\n          this.__validateProperty(clazz, name, config, patch);\n        }\n\n        // Store name into configuration\n        config.name = name;\n\n        // Add config to local registry\n        if (!config.refine)\n        {\n          if (clazz.$$properties === undefined) {\n            clazz.$$properties = {};\n          }\n\n          clazz.$$properties[name] = config;\n        }\n\n        // Store init value to prototype. This makes it possible to\n        // overwrite this value in derived classes.\n        if (config.init !== undefined) {\n          clazz.prototype[\"$$init_\" + name] = config.init;\n        }\n\n        // register event name\n        if (config.event !== undefined) {\n          // break if no events layer loaded\n          if (!qx.core.Environment.get(\"module.events\")) {\n            throw new Error(\"Events module not enabled.\");\n          }\n          var event = {};\n          event[config.event] = \"qx.event.type.Data\";\n          if (config.async) {\n          \tevent[config.event + \"Async\"] = \"qx.event.type.Data\";\n          }\n          this.__addEvents(clazz, event, patch);\n        }\n\n        // Remember inheritable properties\n        if (config.inheritable)\n        {\n          this.__Property.$$inheritable[name] = true;\n          if (!proto.$$refreshInheritables) {\n            this.__Property.attachRefreshInheritables(clazz);\n          }\n        }\n\n        if (!config.refine) {\n          this.__Property.attachMethods(clazz, name, config);\n        }\n        \n        // Add annotations\n        this.__attachAnno(clazz, \"properties\", name, config[\"@\"]);\n      }\n    },\n\n    /**\n     * Validates the given property\n     *\n     * @signature function(clazz, name, config, patch)\n     * @param clazz {Class} class to add property to\n     * @param name {String} name of the property\n     * @param config {Map} configuration map\n     * @param patch {Boolean ? false} enable refine/patch?\n     */\n    __validateProperty : qx.core.Environment.select(\"qx.debug\",\n    {\n      \"true\": function(clazz, name, config, patch)\n      {\n        // check for properties\n        if (!qx.core.Environment.get(\"module.property\")) {\n          throw new Error(\"Property module disabled.\");\n        }\n\n        var has = this.hasProperty(clazz, name);\n\n        if (has)\n        {\n          var existingProperty = this.getPropertyDefinition(clazz, name);\n\n          if (config.refine && existingProperty.init === undefined) {\n            throw new Error(\"Could not refine an init value if there was previously no init value defined. Property '\" + name + \"' of class '\" + clazz.classname + \"'.\");\n          }\n        }\n\n        if (!has && config.refine) {\n          throw new Error(\"Could not refine non-existent property: '\" + name + \"' of class: '\" + clazz.classname + \"'!\");\n        }\n\n        if (has && !patch) {\n          throw new Error(\"Class \" + clazz.classname + \" already has a property: \" + name + \"!\");\n        }\n\n        if (has && patch)\n        {\n          if (!config.refine) {\n            throw new Error('Could not refine property \"' + name + '\" without a \"refine\" flag in the property definition! This class: ' + clazz.classname + ', original class: ' + this.getByProperty(clazz, name).classname + '.');\n          }\n\n          for (var key in config)\n          {\n            if (key !== \"init\" && key !== \"refine\" && key !== \"@\") {\n              throw new Error(\"Class \" + clazz.classname + \" could not refine property: \" + name + \"! Key: \" + key + \" could not be refined!\");\n            }\n          }\n        }\n\n        // Check 0.7 keys\n        var allowed = config.group ? this.__Property.$$allowedGroupKeys : this.__Property.$$allowedKeys;\n        for (var key in config)\n        {\n          if (allowed[key] === undefined) {\n            throw new Error('The configuration key \"' + key + '\" of property \"' + name + '\" in class \"' + clazz.classname + '\" is not allowed!');\n          }\n\n          if (config[key] === undefined) {\n            throw new Error('Invalid key \"' + key + '\" of property \"' + name + '\" in class \"' + clazz.classname + '\"! The value is undefined: ' + config[key]);\n          }\n\n          if (allowed[key] !== null && typeof config[key] !== allowed[key]) {\n            throw new Error('Invalid type of key \"' + key + '\" of property \"' + name + '\" in class \"' + clazz.classname + '\"! The type of the key must be \"' + allowed[key] + '\"!');\n          }\n        }\n\n        if (config.transform != null)\n        {\n          if (!(typeof config.transform === \"string\")) {\n            throw new Error('Invalid transform definition of property \"' + name + '\" in class \"' + clazz.classname + '\"! Needs to be a String.');\n          }\n        }\n\n        if (config.check != null)\n        {\n          if (\n            !qx.Bootstrap.isString(config.check) &&\n            !qx.Bootstrap.isArray(config.check) &&\n            !qx.Bootstrap.isFunction(config.check)\n          ) {\n            throw new Error('Invalid check definition of property \"' + name + '\" in class \"' + clazz.classname + '\"! Needs to be a String, Array or Function.');\n          }\n        }\n      },\n\n      \"default\" : null\n    }),\n\n\n    /**\n     * Attach members to a class\n     *\n     * @param clazz {Class} clazz to add members to\n     * @param members {Map} The map of members to attach\n     * @param patch {Boolean ? false} Enable patching of\n     * @param base {Boolean ? true} Attach base flag to mark function as members\n     *     of this class\n     * @param wrap {Boolean ? false} Whether the member method should be wrapped.\n     *     this is needed to allow base calls in patched mixin members.\n     */\n    __addMembers : function(clazz, members, patch, base, wrap)\n    {\n      var proto = clazz.prototype;\n      var key, member;\n      qx.Bootstrap.setDisplayNames(members, clazz.classname + \".prototype\");\n\n      for (var i=0, a=Object.keys(members), l=a.length; i<l; i++)\n      {\n        key = a[i];\n        member = members[key];\n\n        if (qx.core.Environment.get(\"qx.debug\"))\n        {\n          if (key.charAt(0) === '@') {\n            var annoKey = key.substring(1);\n            if (members[annoKey] === undefined && proto[annoKey] === undefined) {\n              throw new Error('Annonation for \"' + annoKey + '\" of Class \"' + clazz.classname + '\" does not exist!');\n            }\n            if (key.charAt(1) === \"_\" && key.charAt(2) === \"_\") {\n              throw new Error('Cannot annotate private member \"' + key.substring(1) + '\" of Class \"' + clazz.classname);\n            }\n          } else {\n            if (proto[key] !== undefined && key.charAt(0) === \"_\" && key.charAt(1) === \"_\") {\n              throw new Error('Overwriting private member \"' + key + '\" of Class \"' + clazz.classname + '\" is not allowed!');\n            }\n  \n            if (patch !== true && proto.hasOwnProperty(key)) {\n              throw new Error('Overwriting member \"' + key + '\" of Class \"' + clazz.classname + '\" is not allowed!');\n            }\n          }\n        }\n        \n        // Annotations are not members\n        if (key.charAt(0) === '@') {\n          var annoKey = key.substring(1);\n          if (members[annoKey] === undefined) {\n            this.__attachAnno(clazz, \"members\", annoKey, members[key]);\n          }\n          continue;\n        }\n\n        // If it's a property accessor, we need to install it now so that this.base can refer to it\n        if (proto[key] != undefined && proto[key].$$install) {\n        \tproto[key].$$install();\n        }\n\n        // Added helper stuff to functions\n        // Hint: Could not use typeof function because RegExp objects are functions, too\n        // Protect to apply base property and aspect support on special attributes e.g.\n        // classes which are function like as well.\n        if (base !== false && member instanceof Function && member.$$type == null)\n        {\n          if (wrap == true)\n          {\n            // wrap \"patched\" mixin member\n            member = this.__mixinMemberWrapper(member, proto[key]);\n          }\n          else\n          {\n            // Configure extend (named base here)\n            // Hint: proto[key] is not yet overwritten here\n            if (proto[key]) {\n              member.base = proto[key];\n            }\n            member.self = clazz;\n          }\n\n          if (qx.core.Environment.get(\"qx.aspects\")) {\n            member = qx.core.Aspect.wrap(clazz.classname + \".\" + key, member, \"member\");\n          }\n        }\n\n        // Attach member\n        proto[key] = member;\n        \n        // Attach annotations\n        this.__attachAnno(clazz, \"members\", key, members[\"@\" + key]);\n      }\n    },\n\n\n    /**\n     * Wraps a member function of a mixin, which is included using \"patch\". This\n     * allows \"base\" calls in the mixin member function.\n     *\n     * @param member {Function} The mixin method to wrap\n     * @param base {Function} The overwritten method\n     * @return {Function} the wrapped mixin member\n     */\n    __mixinMemberWrapper : function(member, base)\n    {\n      if (base)\n      {\n        return function()\n        {\n          var oldBase = member.base;\n          member.base = base;\n          var retval = member.apply(this, arguments);\n          member.base = oldBase;\n          return retval;\n        };\n      }\n      else\n      {\n        return member;\n      }\n    },\n\n\n    /**\n     * Add a single interface to a class\n     *\n     * @param clazz {Class} class to add interface to\n     * @param iface {Interface} the Interface to add\n     */\n    __addInterface : function(clazz, iface)\n    {\n      if (qx.core.Environment.get(\"qx.debug\"))\n      {\n        if (!clazz || !iface) {\n          throw new Error(\"Incomplete parameters!\");\n        }\n\n        // This differs from mixins, we only check if the interface is already\n        // directly used by this class. It is allowed however, to have an interface\n        // included multiple times by extends in the interfaces etc.\n        if (this.hasOwnInterface(clazz, iface)) {\n          throw new Error('Interface \"' + iface.name + '\" is already used by Class \"' + clazz.classname + '!');\n        }\n\n        // Check interface and wrap members\n        if (clazz.$$classtype !== \"abstract\") {\n          qx.Interface.assert(clazz, iface, true);\n        }\n      }\n\n      // Store interface reference\n      var list = qx.Interface.flatten([iface]);\n      if (clazz.$$implements)\n      {\n        clazz.$$implements.push(iface);\n        clazz.$$flatImplements.push.apply(clazz.$$flatImplements, list);\n      }\n      else\n      {\n        clazz.$$implements = [iface];\n        clazz.$$flatImplements = list;\n      }\n    },\n\n\n    /**\n     * Wrap the constructor of an already existing clazz. This function will\n     * replace all references to the existing constructor with the new wrapped\n     * constructor.\n     *\n     * @param clazz {Class} The class to wrap\n     * @return {Class} The wrapped class\n     */\n    __retrospectWrapConstruct : function(clazz)\n    {\n      var name = clazz.classname;\n      var wrapper = this.__wrapConstructor(clazz, name, clazz.$$classtype);\n\n      // copy all keys from the wrapped constructor to the wrapper\n      for (var i=0, a=Object.keys(clazz), l=a.length; i<l; i++)\n      {\n        key = a[i];\n        wrapper[key] = clazz[key];\n      }\n\n      // fix prototype\n      wrapper.prototype = clazz.prototype;\n\n      // fix self references in members\n      var members = clazz.prototype;\n      for (var i=0, a=Object.keys(members), l=a.length; i<l; i++)\n      {\n        key = a[i];\n        var method = members[key];\n\n        // check if method is available because null values can be stored as\n        // init values on classes e.g. [BUG #3709]\n        if (method && method.self == clazz) {\n          method.self = wrapper;\n        }\n      }\n\n      // fix base and superclass references in all defined classes\n      for(var key in this.$$registry)\n      {\n        var construct = this.$$registry[key];\n        if (!construct) {\n          continue;\n        }\n\n        if (construct.base == clazz) {\n          construct.base = wrapper;\n        }\n        if (construct.superclass == clazz) {\n          construct.superclass = wrapper;\n        }\n\n        if (construct.$$original)\n        {\n          if (construct.$$original.base == clazz) {\n            construct.$$original.base = wrapper;\n          }\n          if (construct.$$original.superclass == clazz) {\n            construct.$$original.superclass = wrapper;\n          }\n        }\n      }\n      qx.Bootstrap.createNamespace(name, wrapper);\n      this.$$registry[name] = wrapper;\n\n      return wrapper;\n    },\n\n\n    /**\n     * Include all features of the mixin into the given class, recursively.\n     *\n     * @param clazz {Class} The class onto which the mixin should be attached.\n     * @param mixin {Mixin} Include all features of this mixin\n     * @param patch {Boolean} Overwrite existing fields, functions and properties\n     */\n    __addMixin : function(clazz, mixin, patch)\n    {\n      if (qx.core.Environment.get(\"qx.debug\"))\n      {\n        if (!clazz || !mixin) {\n          throw new Error(\"Incomplete parameters!\");\n        }\n      }\n\n      if (this.hasMixin(clazz, mixin)) {\n        return;\n      }\n\n      var isConstructorWrapped = clazz.$$original;\n      if (mixin.$$constructor && !isConstructorWrapped) {\n        clazz = this.__retrospectWrapConstruct(clazz);\n      }\n\n      // Attach content\n      var list = qx.Mixin.flatten([mixin]);\n      var entry;\n\n      for (var i=0, l=list.length; i<l; i++)\n      {\n        entry = list[i];\n\n        // Attach events\n        if (entry.$$events) {\n          this.__addEvents(clazz, entry.$$events, patch);\n        }\n\n        // Attach properties (Properties are already readonly themselves, no patch handling needed)\n        if (entry.$$properties) {\n          this.__addProperties(clazz, entry.$$properties, patch);\n        }\n\n        // Attach members (Respect patch setting, but dont apply base variables)\n        if (entry.$$members) {\n          this.__addMembers(clazz, entry.$$members, patch, patch, patch);\n        }\n      }\n\n      // Store mixin reference\n      if (clazz.$$includes)\n      {\n        clazz.$$includes.push(mixin);\n        clazz.$$flatIncludes.push.apply(clazz.$$flatIncludes, list);\n      }\n      else\n      {\n        clazz.$$includes = [mixin];\n        clazz.$$flatIncludes = list;\n      }\n    },\n\n\n\n\n\n    /*\n    ---------------------------------------------------------------------------\n       PRIVATE FUNCTION HELPERS\n    ---------------------------------------------------------------------------\n    */\n\n    /**\n     * Returns the default constructor.\n     * This constructor just calls the constructor of the base class.\n     *\n     * @return {Function} The default constructor.\n     */\n    __createDefaultConstructor : function()\n    {\n      function defaultConstructor() {\n        defaultConstructor.base.apply(this, arguments);\n      }\n\n      return defaultConstructor;\n    },\n\n\n    /**\n     * Checks if the constructor needs to be wrapped.\n     *\n     * @param base {Class} The base class.\n     * @param mixins {Mixin[]} All mixins which should be included.\n     * @return {Boolean} true, if the constructor needs to be wrapped.\n     */\n    __needsConstructorWrapper : function(base, mixins)\n    {\n      if (qx.core.Environment.get(\"qx.debug\")) {\n        return true;\n      }\n\n      // Check for base class mixin constructors\n      if (base && base.$$includes)\n      {\n        var baseMixins=base.$$flatIncludes;\n        for (var i=0, l=baseMixins.length; i<l; i++)\n        {\n          if (baseMixins[i].$$constructor) {\n            return true;\n          }\n        }\n      }\n\n      // check for direct mixin constructors\n      if (mixins)\n      {\n        var flatMixins = qx.Mixin.flatten(mixins);\n        for (var i=0, l=flatMixins.length; i<l; i++)\n        {\n          if (flatMixins[i].$$constructor) {\n            return true;\n          }\n        }\n      }\n\n      return false;\n    },\n\n\n    /**\n     * Generate a wrapper of the original class constructor in order to enable\n     * some of the advanced OO features (e.g. abstract class, singleton, mixins)\n     *\n     * @param construct {Function} the original constructor\n     * @param name {String} name of the class\n     * @param type {String} the user specified class type\n     * @return {Function} The wrapped constructor\n     */\n    __wrapConstructor : function(construct, name, type)\n    {\n      var wrapper = function()\n      {\n        var clazz = wrapper;\n\n        if (qx.core.Environment.get(\"qx.debug\"))\n        {\n          // new keyword check\n          if (!(this instanceof clazz)) {\n            throw new Error(\"Please initialize '\" + name + \"' objects using the new keyword!\");\n          }\n\n          // add abstract and singleton checks\n          if (type === \"abstract\")\n          {\n            if (this.classname===name) {\n              throw new Error(\"The class ',\" + name + \"' is abstract! It is not possible to instantiate it.\");\n            }\n          }\n          else if (type === \"singleton\")\n          {\n            if (!clazz.$$allowconstruct) {\n              throw new Error(\"The class '\" + name + \"' is a singleton! It is not possible to instantiate it directly. Use the static getInstance() method instead.\");\n            }\n          }\n        }\n\n        // Execute default constructor\n        var retval=clazz.$$original.apply(this,arguments);\n\n        // Initialize local mixins\n        if (clazz.$$includes)\n        {\n          var mixins=clazz.$$flatIncludes;\n          for (var i=0, l=mixins.length; i<l; i++)\n          {\n            if (mixins[i].$$constructor) {\n              mixins[i].$$constructor.apply(this,arguments);\n            }\n          }\n        }\n\n        if (qx.core.Environment.get(\"qx.debug\")) {\n          // Mark instance as initialized\n          if (this.classname === name) {\n            this.$$initialized = true;\n          }\n        }\n\n        // Return optional return value\n        return retval;\n      };\n\n      if (qx.core.Environment.get(\"qx.aspects\"))\n      {\n        var aspectWrapper = qx.core.Aspect.wrap(name, wrapper, \"constructor\");\n        wrapper.$$original = construct;\n        wrapper.constructor = aspectWrapper;\n        wrapper = aspectWrapper;\n      }\n\n      // Store original constructor\n      wrapper.$$original = construct;\n\n      // Store wrapper into constructor (needed for base calls etc.)\n      construct.wrapper = wrapper;\n\n      // Return generated wrapper\n      return wrapper;\n    }\n  },\n\n  defer : function()\n  {\n    // Binding of already loaded bootstrap classes\n    if (qx.core.Environment.get(\"qx.aspects\"))\n    {\n      for (var classname in qx.Bootstrap.$$registry)\n      {\n        var statics = qx.Bootstrap.$$registry[classname];\n\n        for (var key in statics)\n        {\n          // only functions, no regexps\n          if (statics[key] instanceof Function) {\n            statics[key] = qx.core.Aspect.wrap(classname + \".\" + key, statics[key], \"static\");\n          }\n        }\n      }\n    }\n  }\n});\n"
  ]
}